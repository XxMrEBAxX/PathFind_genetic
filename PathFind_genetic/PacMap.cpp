#include "PacMap.h"

PacMap::PacMap(POSITION pos)
{
	endPos = pos;

	TileMap = new int*[MAP_Y];
	for (int i = 0; i < MAP_Y; i++)
	{
		TileMap[i] = new int[MAP_X];
	}
	InitMap();
}

PacMap::PacMap(const PacMap& _Value)
{
	TileMap = new int* [MAP_Y];
	for (int i = 0; i < MAP_Y; i++)
	{
		TileMap[i] = new int[MAP_X];
	}

	for (int i = 0; i < MAP_Y; i++)
	{
		for (int j = 0; j < MAP_X; j++)
		{
			TileMap[i][j] = _Value.TileMap[i][j];
		}
	}
}

PacMap::~PacMap()
{
	for (int i = 0; i < MAP_Y; i++)
	{
		delete[] TileMap[i];
	}
	delete[] TileMap;
}

void PacMap::InitMap()
{
#define け 0
#define し 1
	int tempMap[MAP_Y][MAP_X] = {
		//   1   2   3   4   5   6  7   8   9  10  11  12  13  14  15 16  17  18  19  20 21  22  23  24  25 26  27  28
			{け, け, け, け, け, け, け, け, け, け, け, け, け, け, け, け, け, け, け, け, け, け, け, け, け, け, け, け},// 1
			{け, し, し, し, し, し, し, し, し, し, し, し, し, け, け, し, し, し, し, し, し, し, し, し, し, し, し, け},// 2
			{け, し, け, け, け, け, し, け, け, け, け, け, し, け, け, し, け, け, け, け, け, し, け, け, け, け, し, け},// 3
			{け, し, け, け, け, け, し, け, け, け, け, け, し, け, け, し, け, け, け, け, け, し, け, け, け, け, し, け},// 4
			{け, し, け, け, け, け, し, け, け, け, け, け, し, け, け, し, け, け, け, け, け, し, け, け, け, け, し, け},// 5
			{け, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, け},// 6
			{け, し, し, し, し, し, し, け, け, し, し, し, し, け, け, し, し, し, し, け, け, し, し, し, し, し, し, け},// 7
			{け, し, し, し, し, し, し, け, け, し, し, し, し, け, け, し, し, し, し, け, け, し, し, し, し, し, し, け},// 8
			{け, し, し, し, し, し, し, け, け, し, し, し, し, け, け, し, し, し, し, け, け, し, し, し, し, し, し, け},// 9
			{け, け, け, け, け, け, し, け, け, け, け, け, し, け, け, し, け, け, け, け, け, し, け, け, け, け, け, け},// 10
			{け, け, け, け, け, け, し, け, け, け, け, け, し, け, け, し, け, け, け, け, け, し, け, け, け, け, け, け},// 11
			{け, け, け, け, け, け, し, け, け, し, し, し, し, し, し, し, し, し, し, け, け, し, け, け, け, け, け, け},// 12
			{け, け, け, け, け, け, し, け, け, し, け, け, け, し, し, け, け, け, し, け, け, し, け, け, け, け, け, け},// 13
			{け, け, け, け, け, け, し, け, け, し, け, け, し, し, し, し, け, け, し, け, け, し, け, け, け, け, け, け},// 14
			{し, し, し, し, し, し, し, し, し, し, け, け, し, し, し, し, け, け, し, し, し, し, し, し, し, し, し, し},// 15
			{け, け, け, け, け, け, し, け, け, し, け, け, し, し, し, し, け, け, し, け, け, し, け, け, け, け, け, け},// 16
			{け, け, け, け, け, け, し, け, け, し, け, け, け, け, け, け, け, け, し, け, け, し, け, け, け, け, け, け},// 17
			{け, け, け, け, け, け, し, け, け, し, け, け, け, け, け, け, け, け, し, け, け, し, け, け, け, け, け, け},// 18
			{け, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, け},// 19
			{け, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, け},// 20
			{け, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, け},// 21
			{け, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, け},// 22
			{け, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, け},// 23
			{け, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, け},// 24
			{け, け, け, し, け, け, し, け, け, し, け, け, け, け, け, け, け, け, し, け, け, し, け, け, し, け, け, け},// 25
			{け, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, け},// 26
			{け, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, け},// 27
			{け, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, け},// 28
			{け, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, け},// 29
			{け, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, し, け},// 30
			{け, け, け, け, け, け, け, け, け, け, け, け, け, け, け, け, け, け, け, け, け, け, け, け, け, け, け, け} // 31
	};

	for (int i = 0; i < MAP_Y; i++)
	{
		for (int j = 0; j < MAP_X; j++)
		{
			TileMap[i][j] = tempMap[i][j];
		}
	}
}

void PacMap::DrawMap()
{
	for (int i = 0; i < MAP_Y; i++)
	{
		for (int j = 0; j < MAP_X; j++)
		{
			if (TileMap[i][j] == 0) // 混
			{
				cout << "＝";
			}
			else if (TileMap[i][j] == 2) // 走蟹娃 掩
			{
				cout << "＋";
			}
			else if (TileMap[i][j] == 3)
			{
				cout << "】";
			}
			else
			{
				cout << "  ";
			}
		}
		cout << endl;
	}
}

bool PacMap::Move(POSITION& pos, int dir)
{
	int dx;
	int dy;
	switch (dir)
	{
	case 0:
		dx = 0;
		dy = -1;
		break;
	case 1:
		dx = 1;
		dy = 0;
		break;
	case 2:
		dx = 0;
		dy = 1;
		break;
	case 3:
		dx = -1;
		dy = 0;
		break;
	}
	int moveX = pos.X + dx;
	int moveY = pos.Y + dy;

	if ((moveX >= MAP_X || moveX < 0) || (moveY >= MAP_Y || moveY < 0))
		return false;

	bool isMove = TileMap[moveY][moveX] == 0 ? false : true;
	if (isMove)
	{
		pos = POSITION(moveX, moveY);
		if(TileMap[moveY][moveX] != 3)
			setTile(pos, 2);
		if (pos == endPos)
			setTile(pos, 3);
	}

	return isMove;
}
